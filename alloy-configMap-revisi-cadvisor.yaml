apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
  namespace: monitoring
data:
  config.alloy: |
    discovery.kubernetes "pods" {
      role = "pod"
    }

    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        separator     = "/"
        target_label  = "__path__"
        replacement   = "/var/log/pods/*$1/*.log"
      }

      rule {
        source_labels = ["__meta_kubernetes_pod_container_id"]
        regex         = "^(\\w+):\\/\\/.+$"
        replacement   = "$1"
        target_label  = "tmp_container_runtime"
      }
    }

    local.file_match "pod_logs" {
      path_targets = discovery.relabel.pod_logs.output
    }

    loki.source.file "pod_logs" {
      targets    = local.file_match.pod_logs.targets
      forward_to = [loki.process.pod_logs.receiver]
    }

    loki.process "pod_logs" {
      stage.match {
        selector = "{tmp_container_runtime=\"containerd\"}"
        stage.cri {}
      }

      stage.match {
        selector = "{tmp_container_runtime=\"docker\"}"
        stage.docker {}
      }

      stage.label_drop {
        values = ["tmp_container_runtime"]
      }

      forward_to = [loki.write.loki.receiver]
    }

    loki.write "loki" {
      endpoint {
        url = "http://loki-gateway.monitoring.svc.cluster.local/loki/api/v1/push"
      }
    }

    prometheus.exporter.unix "node" {}

    discovery.relabel "node" {
      targets = prometheus.exporter.unix.node.targets

      rule {
        target_label = "job"
        replacement  = "node-exporter"
      }
    }

    prometheus.scrape "node" {
      targets    = discovery.relabel.node.output
      forward_to = [prometheus.remote_write.mimir_nodes.receiver]
    }

    prometheus.remote_write "mimir_nodes" {
      endpoint {
        url = "http://mimir-gateway.monitoring.svc.cluster.local/api/v1/push"
        headers = {
          "X-Scope-OrgID" = "nodes",
        }
      }
    }

    discovery.kubernetes "kubelet_nodes" {
      role = "node"
    }

    discovery.relabel "kubelet_cadvisor" {
      targets = discovery.kubernetes.kubelet_nodes.targets

      rule {
        source_labels = ["__meta_kubernetes_node_address_InternalIP"]
        regex         = ""
        action        = "drop"
      }

      rule {
        source_labels = ["__meta_kubernetes_node_address_InternalIP"]
        target_label  = "__address__"
        replacement   = "$1:10250"
      }

      rule {
        target_label = "__metrics_path__"
        replacement  = "/metrics/cadvisor"
      }
    }

    prometheus.scrape "kubelet_cadvisor" {
      targets = discovery.relabel.kubelet_cadvisor.output
      scheme  = "https"

      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

      tls_config {
        insecure_skip_verify = true
      }

      forward_to = [prometheus.remote_write.mimir_pods.receiver]
    }

    prometheus.remote_write "mimir_pods" {
      endpoint {
        url = "http://mimir-gateway.monitoring.svc.cluster.local/api/v1/push"
        headers = {
          "X-Scope-OrgID" = "pods",
        }
      }
    }

    discovery.kubernetes "kube_state_metrics" {
      role = "service"
    }

    discovery.relabel "kube_state_metrics" {
      targets = discovery.kubernetes.kube_state_metrics.targets

      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        regex         = "kube-state-metrics"
        action        = "keep"
      }

      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        regex         = "monitoring"
        action        = "keep"
      }

      rule {
        target_label = "__address__"
        replacement  = "kube-state-metrics.monitoring.svc.cluster.local:8080"
      }
    }

    prometheus.scrape "kube_state_metrics" {
      targets    = discovery.relabel.kube_state_metrics.output
      forward_to = [prometheus.remote_write.mimir_pods.receiver]
    }

    otelcol.receiver.otlp "default" {
      grpc {}
      http {}
      output {
        traces = [otelcol.processor.k8sattributes.default.input]
      }
    }

    otelcol.processor.k8sattributes "default" {
      extract {
        metadata = [
          "k8s.namespace.name",
          "k8s.pod.name",
          "k8s.node.name",
        ]
      }
      output {
        traces = [otelcol.processor.batch.default.input]
      }
    }

    otelcol.processor.batch "default" {
      output {
        traces = [otelcol.exporter.otlp.tempo.input]
      }
    }

    otelcol.exporter.otlp "tempo" {
      client {
        endpoint = "tempo-distributor.monitoring.svc.cluster.local:4317"
        tls {
          insecure = true
        }
      }
    }

    discovery.kubernetes "local_pods" {
      selectors {
        field = "spec.nodeName=" + env("HOSTNAME")
        role  = "pod"
      }
      role = "pod"
    }

    pyroscope.ebpf "cpu" {
      targets    = discovery.kubernetes.local_pods.targets
      forward_to = [pyroscope.write.pyroscope.receiver]
    }

    pyroscope.write "pyroscope" {
      endpoint {
        url = "http://pyroscope-distributor.monitoring.svc.cluster.local:4040"
      }
    }
